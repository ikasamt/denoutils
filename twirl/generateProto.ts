import * as t from "npm:proto-parser";

function fetchFunc(): string {
  return `
let endpointURL: string;
let endpointToken: string;

export function setEndpoint(url: string, token: string) {
  endpointURL = url;
  endpointToken = token;
}

export async function fetchJSON(url: string, req: any) {
  const res = await fetch(endpointURL + url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + endpointToken,
    },
    body: JSON.stringify(req),
  });
  return res;
}
`;
}

export async function generateProto(fileName: string): string {
  const content = await Deno.readTextFile(fileName);
  const protoDocument = t.parse(content) as t.ProtoDocument;
  console.log(protoDocument);

  let lines: string[] = [];
  lines.push(fetchFunc());

  let messages = [];
  let services = [];

  const packageName = protoDocument.package;
  let serviceName = "";

  lines.push(`//`);
  lines.push(`// ${packageName} generated by twirl`);
  lines.push(`//`);

  const tmp = packageName.split(".");
  let docs = protoDocument["root"];
  for (const t of tmp) {
    docs = docs.nested[t];
  }

  for (const key in docs.nested) {
    const value = docs.nested[key];

    switch (value.syntaxType) {
      case "MessageDefinition":
        messages.push(value);
        break;
      case "ServiceDefinition":
        services.push(value);
        break;
      default:
        break;
      //   console.log(value.syntaxType);
    }
  }

  for (const message of messages) {
    lines.push(`export interface ${message.name} {`);
    for (const field in message.fields) {
      const v = message.fields[field];
      let type_ = v.type.value;
      switch (type_) {
        case "bool":
          type_ = "boolean";
          break;
        case ("int32", "int64"):
          type_ = "number";
          break;
        case ("uint32", "uint64"):
          type_ = "number";
          break;
        case ("float", "double"):
          type_ = "number";
          break;
      }
      lines.push(`  ${v.name}: ${type_}${v.repeated ? "[]" : ""};`);
    }
    lines.push(`}`);
    lines.push(``);
  }

  for (const service of services) {
    serviceName = service.name;
    lines.push(`//`);
    lines.push(`// ${serviceName}`);
    lines.push(`//`);
    for (const methodName in service.methods) {
      const v = service.methods[methodName];
      lines.push(`// ${v.name}`);
      lines.push(`export async function ${methodName}(`);
      lines.push(`  req: ${v.requestType.value}`);
      lines.push(`): Promise<${v.responseType.value}> {`);
      lines.push(
        `  const res = await fetchJSON("${packageName}.${serviceName}/${v.name}", req)`
      );
      lines.push(`  return (await res.json()) as ${v.responseType.value}`);
      lines.push(`}`);
      lines.push(``);
    }
  }

  return lines.join("\n");
}
